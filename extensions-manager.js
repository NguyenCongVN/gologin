const path = require('path');
const request = require('requestretry').defaults({ timeout: 60000 });
const fs = require('fs');
const { mkdir, readdir, rmdir } = require('fs').promises;
const os = require('os');

const  ExtensionsExtractor = require('./extensions-extractor');

const HOMEDIR = os.homedir();
const CHROME_EXT_DIR_NAME = 'chrome-extensions';
const EXTENSIONS_PATH = path.join(HOMEDIR, '.gologin', 'extensions');
const CHROME_EXTENSIONS_PATH = path.join(EXTENSIONS_PATH, CHROME_EXT_DIR_NAME);
const EXTENSION_URL = 'https://clients2.google.com/service/update2/crx?response=redirect&acceptformat=crx2,crx3&x=id%3D{ext_id}%26uc&prodversion=97.0.4692.71';

/**
 * Class for managing Chrome extensions for the GoLogin service.
 */
class ExtensionsManager {
  #USER_AGENT = '';
  #API_BASE_URL = '';
  #ACCESS_TOKEN = '';
  #existedChromeExtensions = [];
  #inited = false;
  #useLocalExtStorage = false;
  #deleteProfileExtFolders = false;
  #deleteWidevineCdmFolder = false;

    /**
   * Initializes the ExtensionsManager instance.
   * @returns {Promise<void>}
   */
  constructor() {
    if (!ExtensionsManager.instance) {
      ExtensionsManager.instance = this;
    }

    return ExtensionsManager.instance;
  }

 
  /**
   * Checks if the ExtensionsManager instance has been initialized.
   * @returns {boolean} true if initialized, false otherwise.
   */
  get isInited() { return this.#inited }
  /**
  * Checks if the ExtensionsManager instance is set to use local extension storage.
  * @returns {boolean} true if using local storage, false otherwise.
  */
  get useLocalExtStorage() { return this.#useLocalExtStorage }
   /**
   * Checks if the ExtensionsManager instance is set to delete profile extension folders.
   * @returns {boolean} true if deleting profile extension folders, false otherwise.
   */
  get deleteProfileExtFolders() { return this.#deleteProfileExtFolders }
  /**
   * Checks if the ExtensionsManager instance is set to delete the Widevine CDM folder.
   * @returns {boolean} true if deleting the Widevine CDM folder, false otherwise.
   */
  get deleteWidevineCdmFolder() { return this.#deleteWidevineCdmFolder }

  /**
   * Sets the user agent for the ExtensionsManager instance.
   * @param {string} userAgent - The user agent string to set.
   */
  set userAgent(userAgent) {
    if (!userAgent) {
      return;
    }

    this.#USER_AGENT = userAgent;
  }

  /**
   * Sets the access token for the ExtensionsManager instance.
   * @param {string} accessToken - The access token to set.
   */
  set accessToken(accessToken) {
    if (!accessToken) {
      return;
    }

    this.#ACCESS_TOKEN = accessToken;
  }

  set apiUrl(apiUrl) {
    if (!apiUrl) {
      return;
    }

    this.#API_BASE_URL = apiUrl;
  }

  /**

Initializes the ExtensionsManager instance by creating the chrome extensions directory if it does not exist,
reads the existing chrome extensions from the directory and sets the #inited flag to true.
@async
@function
@returns {Promise<void>} - A promise that resolves after the instance has been initialized.
*/
  init() {
    if (this.#inited) {
      return Promise.resolve();
    }

    return mkdir(CHROME_EXTENSIONS_PATH, { recursive: true })
      .then(() => readdir(CHROME_EXTENSIONS_PATH))
      .then(filesList => {
        this.#existedChromeExtensions = filesList;
        this.#inited = true;
      })
      .catch((e) => console.log('ExtensionsManager init error:', e));
  }

  get existedChromeExtensionsList() {
    return this.#existedChromeExtensions;
  }

  /**

Downloads and extracts the Chrome extensions required by the given profileExtensions list
@async
@param {Array} profileExtensions - A list of Chrome extension IDs and versions in the format of "<ID>@<VERSION>".
@returns {Array} - A list of extracted Chrome extensions directories
*/
  async checkChromeExtensions(profileExtensions = []) {
    if (!(Array.isArray(profileExtensions) && profileExtensions.length)) {
      return [];
    }

    const extensionsToDownload = this.#getExtensionsToDownload(profileExtensions);
    if (!extensionsToDownload) {
      return [];
    }

    const downloadedArchives = await this.downloadChromeExtensions(extensionsToDownload);
    const filteredArchives = downloadedArchives.filter(Boolean);
    const promises = composeExtractionPromises(filteredArchives);

    await Promise.all(promises);
    return this.getExtensionsStrToIncludeAsOrbitaParam(profileExtensions);
  }

  #getExtensionsToDownload(profileExtensions) {
    const existedOriginalIds = this.#existedChromeExtensions.map((val) => {
      const [originalId] = val.split('@');
      return originalId;
    });

    return profileExtensions.reduce((res, val) => {
      const [originalId] = val.split('@');
      const extensionExists = existedOriginalIds.includes(originalId);
      if (!extensionExists) {
        res.push(val);
      }

      return res;
    }, []);
  }

  async downloadChromeExtensions(idsToDownload = []) {
    if (!(Array.isArray(idsToDownload) && idsToDownload.length)) {
      return [];
    }

    const promises = idsToDownload.map(async (id) => {
      const [originalId] = id.split('@');
      const extUrl = EXTENSION_URL.replace('{ext_id}', originalId);

      const uploadedProfileMetadata = await getExtMetadata(extUrl);

      const reqPath = uploadedProfileMetadata.req.path;
      const extVer = getExtVersion(reqPath);

      const buffer = await new Promise((res) => {
        const chunks = []
        request.get(extUrl, {
          maxAttempts: 3,
          retryDelay: 1000,
          timeout: 8 * 1000,
          fullResponse: false,
        })
          .on('data', (data) => chunks.push(data))
          .on('end', () => res(Buffer.concat(chunks)));
      });

      let zipExt;
      try {
        zipExt = crxToZip(buffer);
      } catch (e) {
        console.log(e);
        return '';
      }

      const archiveZipPath = path.join(CHROME_EXTENSIONS_PATH, originalId + '@' + extVer + '.zip');

      const archiveZip = fs.createWriteStream(archiveZipPath);
      archiveZip.write(zipExt);
      archiveZip.close();

      return new Promise(r => archiveZip.on('close', () => r(archiveZipPath)));
    });

    return Promise.all(promises);
  }

  async getExtensionsPolicies() {
    const globalExtConfig = await request.get(`${this.#API_BASE_URL}/gologin-settings/chrome_ext_policies`, {
      headers: {
        Authorization: `Bearer ${this.#ACCESS_TOKEN}`,
        'user-agent': this.#USER_AGENT,
      },
      json: true,
      maxAttempts: 2,
      retryDelay: 1000,
      timeout: 10 * 1000,
      fullResponse: false,
    });

    const chromeExtPolicies = globalExtConfig?.chromeExtPolicies || {};
    const {
      useLocalExtStorage = false,
      deleteProfileExtFolders = false,
      deleteWidevineCdmFolder = false,
    } = chromeExtPolicies;

    this.#useLocalExtStorage = useLocalExtStorage;
    this.#deleteProfileExtFolders = deleteProfileExtFolders;
    this.#deleteWidevineCdmFolder = deleteWidevineCdmFolder;
  }

  async getExtensionsStrToIncludeAsOrbitaParam(profileExtensions = []) {
    if (!(Array.isArray(profileExtensions) && profileExtensions.length)) {
      return [];
    }

    const chromeExtList = await readdir(CHROME_EXTENSIONS_PATH);
    if (!chromeExtList) {
      return [];
    }

    const formattedIdsList = chromeExtList.map((el) => {
      const [originalId] = el.split('@');
      return {
        originalId,
        folderName: el,
      };
    });

    return profileExtensions.map((el) => {
      const extExisted = formattedIdsList.find(chromeExtPathElem => chromeExtPathElem.originalId === el);
      if (!extExisted) {
        return '';
      }

      return path.join(CHROME_EXTENSIONS_PATH, extExisted.folderName);
    }).filter(Boolean);
  }

  async updateExtensions() {
    const fileList = await readdir(CHROME_EXTENSIONS_PATH).catch(() => []);
    if (!fileList.length) {
      return;
    }

    const oldFolders = [];

    const versionCheckPromises = fileList.map(async (extension) => {
      if (!extension.includes('@')) {
        return '';
      }

      const [originalId, currentVersion] = extension.split('@');
      const extUrl = EXTENSION_URL.replace('{ext_id}', originalId);
      const uploadedProfileMetadata = await getExtMetadata(extUrl);
      const reqPath = uploadedProfileMetadata.req.path;
      const availableVersion = getExtVersion(reqPath);

      if (currentVersion === availableVersion) {
        return '';
      }

      oldFolders.push(path.join(CHROME_EXTENSIONS_PATH, extension));
      return originalId;
    });

    const extensionsNames = (await Promise.all(versionCheckPromises)).filter(Boolean);
    const archivesPaths = (await this.downloadChromeExtensions(extensionsNames)).filter(Boolean);
    const extractionPromises = composeExtractionPromises(archivesPaths);
    await Promise.all(extractionPromises);

    const removeFoldersPromises = oldFolders.map(folder => (
      rmdir(folder, { recursive: true, maxRetries: 3 }).catch(() => {})
    ));

    return Promise.all(removeFoldersPromises);
  }

  getExtensionsToInstall(extensionsFromPref, extensionsFromDB) {
    if (!extensionsFromPref) {
      return [];
    }

    const objectEntries = Object.entries(extensionsFromPref);
    const extensionsInPref = objectEntries?.map(([_, settings]) => {
      const [extFolderName] = settings.path.split(path.sep).reverse();
      const [originalId] = extFolderName.split('@');
      return originalId;
    }) || [];

    return extensionsFromDB.reduce((acc, extension) => {
      const [extFolderName] = extension.split(path.sep).reverse();
      const [originalId] = extFolderName.split('@');
      if (!extensionsInPref.includes(originalId)) {
        acc.push(extension);
      }
      return acc;
    }, []);
  }
}

const crxToZip = (buf) => {
  if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4) {
    return buf;
  }

  if (!(buf[0] === 67 || buf[1] === 114 || buf[2] === 50 || buf[3] === 52)) {
    throw new Error('Invalid header: Does not start with Cr24');
  }

  const isV3 = buf[4] === 3;
  const isV2 = buf[4] === 2;

  if (!(isV2 || isV3) || buf[5] || buf[6] || buf[7]) {
    throw new Error('Unexpected crx format version number.');
  }

  if (isV2) {
    const publicKeyLength = calcLength(buf[8], buf[9], buf[10], buf[11]);
    const signatureLength = calcLength(buf[12], buf[13], buf[14], buf[15]);

    const zipStartOffset = 16 + publicKeyLength + signatureLength;
    return buf.slice(zipStartOffset, buf.length);
  }

  const headerSize = calcLength(buf[8], buf[9], buf[10], buf[11]);
  const zipStartOffset = 12 + headerSize;

  return buf.slice(zipStartOffset, buf.length);
}

const calcLength = (a, b, c, d) => {
  let length = 0;

  length += a << 0;
  length += b << 8;
  length += c << 16;
  length += d << 24 >>> 0;
  return length;
}

const getExtMetadata = (extUrl) => (
  request.head(extUrl, {
    maxAttempts: 3,
    retryDelay: 2000,
    timeout: 2 * 1000,
    fullResponse: true,
  })
);

const getExtVersion = (metadata) => {
  const [extFullName = ''] = metadata.split('/').reverse();
  const [extName = ''] = extFullName.split('.');
  const splitExtName = extName.split('_');
  splitExtName.shift();
  return splitExtName.join('_');
};

const composeExtractionPromises = (filteredArchives) => (
  filteredArchives.map((extArchivePath) => {
    const [archiveName = ''] = extArchivePath.split(path.sep).reverse();
    const [destFolder] = archiveName.split('.');
    return ExtensionsExtractor.extractExtension(extArchivePath, path.join(CHROME_EXTENSIONS_PATH, destFolder))
      .then(() => ExtensionsExtractor.deleteExtensionArchive(extArchivePath))
  })
);

module.exports = ExtensionsManager;


